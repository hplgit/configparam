
The aim of this book is to teach computer programming using
examples from mathematics and the natural sciences.
We have chosen to use the Python programming language because it
combines remarkable power with very clean, simple, and compact syntax.
Python is easy to learn and very well suited for an introduction to
computer programming. Python is also quite similar to Matlab and
a good language for doing mathematical computing.
It is easy to combine Python with compiled languages, like Fortran, C, and
C++, which are widely used languages for scientific computations.
A seamless integration of Python with Java is offered by a special
version of Python called Jython.

%\para{Why Python?}
%Python is simple, powerful, portable, free, etc.
%Can be short here, maybe quote Martelli p 4, paragraphs 1, 3, and 4.
%Add Jython/Java integration and Matlab-style support.
%See also Brown \cite[Ch.~1]{BrownRef} and Laningham \cite{Python24hours}

The examples in this book integrate programming with applications to
mathematics, physics, biology, and finance.  The reader is expected to
have knowledge of basic one-variable calculus as taught in
mathematics-intensive programs in high schools. It is certainly an
advantage to take a university calculus course in parallel, preferably
containing both classical and numerical aspects of calculus.  Although
not strictly required, a background in high school physics makes many
of the examples more meaningful.

Many introductory programming books are quite compact and focus on
listing functionality of a programming language. However, learning to
program is learning how to \emph{think} as a programmer.  This book
has its main focus on the thinking process, or equivalently:
programming as a problem solving technique. That is why most of the
pages are devoted to case studies in programming, where we define a
problem and explain how to create the corresponding program.  New
constructions and programming styles (what we could call theory) is also usually
introduced via examples.  Special attention is paid to verification of
programs and to finding errors. These topics are very demanding for
mathematical software, because the unavoidable numerical
approximation errors are possibly mixed with programming mistakes.

By studying the many examples in the
book, I hope readers will learn how to think right and thereby
write programs in a quicker and more reliable way. Remember, nobody can learn
programming by just reading -- one has to solve a large amount of
exercises hands on.  The book is therefore full of exercises of
various types: modifications of existing examples, completely new
problems, or debugging of given programs.

To work with this book, I recommend to use Python version 2.7 (although
version 2.6 will work for most of the material).
For Chapters~\ref{ch:plot}--\ref{ch:oo} and Appendices~\ref{ch:diffeq}--\ref{ch:ode2}
you also need the NumPy, Matplotlib, SciTools packages.
There is a web page
associated with this book,
\emp{http://www.simula.no/intro-programming},
which lists the software you need and explains briefly how to install it.
On this page, you will also find all
the files associated with the program examples
in this book. Download
\emp{book-examples.tar.gz}, store this file
in some folder of your choice, and unpack it
using WinZip on
Windows or the command
\emp{tar xzf book-examples.tar.gz}
on Linux and Mac.
This unpacking yields a folder \emp{src} with subfolders for the
various chapters in the book.

\para{Python version 2 or 3?}
A common problem among Python programmers is to choose between version
2 or 3, which at the time of this writing means choosing
between version 2.7 and 3.1.
The general recommendation is to go for version 3, but programs are
then not compatible with version 2 and vice versa. There is still
a problem that much useful mathematical software in Python
has not yet been ported to version 3. Therefore, scientific computing
with Python still goes mostly with version 2.
A widely used strategy for software
developers who want to write Python code that works with both versions,
is to develop for v2.7, which is very close to v3.1, and then
use the ranslation tool \emph{2to3} to automatically translate the code
to version 3.1.

When using v2.7, one should employ the newest syntax
and modules that make the differences beween version 2 and 3 very small.
This strategy is adopted in the present book. Only two
differences between version 2 and 3 are expected to be significant for
the programs in the book:
\emp{a/b} implies float division in version 3 if \emp{a} and \emp{b}
are integers,
and \emp{print 'Hello'} in version 2 must be turned into a function call
\emp{print('Hello')} in version 3. None of these differences should lead
to any annoying problems when future readers study the book's v2.7
examples, but program in version 3. Anyway, running 2to3 on the
example files generates the corresponding version 3 code.


%The present version of the book is preliminary and contains probably
%a lot of typos, but hopefully not so many serious errors.
%If you detect any type of errors, please email them to \emp{hpl@simula.no}.

\para{Contents.}
Chapter~\ref{ch:formula1} introduces variables, objects, modules, and
text formatting through examples concerning evaluation of mathematical
formulas.  Chapter~\ref{ch:looplist} presents programming with \emp{while}
and \emp{for} loops as well as with lists, including nested lists.
The next chapter deals with two other fundamental concepts in
programming: functions and \emp{if}-\emp{else} tests. Successful
further reading of the book demands that Chapters~\ref{ch:formula1}--\ref{ch:funcif} are digested.

How to read data into programs and deal with errors in input are the
subjects of Chapter~\ref{ch:input}.  Chapter~\ref{ch:plot} introduces
arrays and array computing (including vectorization) and how this is
used for plotting $y=f(x)$ curves and making animation of curves.
Many of the examples in the first five chapters are strongly
related. Typically, formulas from the first chapter are used to
produce tables of numbers in the second chapter.  Then the formulas
are encapsulated in functions in the third chapter. In the
next chapter, the input to the
functions are fetched from the command line, or from a question-answer
dialog with the user, and validity checks of the input
are added.  The formulas are then shown as graphs in Chapter~\ref{ch:plot}.
After having studied
Chapters~\ref{ch:formula1}-~\ref{ch:plot}, the reader should have
enough knowledge of programming to solve mathematical problems by
``Matlab-style'' programming.


Chapter~\ref{ch:files} explains how to work with files
and text data.
%String processing, text interpretation, downloading data from the
%Internet, and storing information in dictionaries (hash maps) are
%key topics in this chapter.
Class programming, including
user-defined types for
mathematical computations (with overloaded operators),
is introduced in Chapter~\ref{ch:class}.
Chapter~\ref{ch:random} deals with random numbers and statistical
computing with applications to games and random walks.
Object-oriented programming, in the meaning of class hierarchies and
inheritance,
is the subject of Chapter~\ref{ch:oo}. The key examples here
deal with building toolkits for
numerical differentiation and integration as well as graphics.

Appendix~\ref{ch:diffeq} introduces mathematical modeling, using
sequences and difference equations. We also treat sound
as a sequence. Only programming concepts from Chapters~\ref{ch:formula1}--\ref{ch:plot} are used in this appendix,
the aim being to consolidate basic programming knowledge
and apply it to mathematical problems. Some important mathematical
topics are introduced via difference equations in a simple way:
Newton's method, Taylor
series, inverse functions, and dynamical systems.

Appendix~\ref{ch:dcalculus} deals with functions on a mesh,
numerical differentiation, and numerical integration.
%Functions of one and two variables are treated.
A simple introduction to ordinary differential equations and their
numerical treatment is provided in Appendix~\ref{ch:ode1}.
Appendix~\ref{appendix:proj} shows how a complete project in physics
can be solved by mathematical modeling, numerical methods, and
programming elements from Chapters~\ref{ch:formula1}--\ref{ch:plot}.
This project is a
good example on problem solving in computational science, where it is
necessary to integrate physics, mathematics, numerics, and computer
science.

How to create software for solving systems of ordinary differential equations,
primarily using classes and object-oriented programming, is the subject of
Appendix~\ref{ch:ode2}. The material in this appendix brings together
many of the programming concepts from Chapters~\ref{ch:formula1}--\ref{ch:oo}
in a mathematical setting and ends up with a flexible and general
tool for solving differential equations.


Appendix~\ref{appendix:debugging} is devoted to the art of debugging,
and in fact problem solving in general, while
Appendix~\ref{appendix:tech} deals with various more advanced
technical topics.

Most of the examples and exercises in this book are quite compact
and limited. However, many of the exercises are related,
and together they form larger projects in science, for example on
Fourier Series (\ref{sec:formula:ex10},
\ref{sec:input:ex17}--\ref{sec:input:ex19}, \ref{sec:plot:ex8},
\ref{sec:plot:ex8m}),
Taylor series (\ref{sec:basic:ex29e}, \ref{sec:plot:ex5b}, \ref{sec:plot:ex17}, \ref{sec:diffeq:ex11b}, \ref{sec:diffeq:ex15}, \ref{sec:class:ex5}),
piecewise constant functions (\ref{sec:basic:exH1}--\ref{sec:basic:exH4},
\ref{sec:plot:ex32}, \ref{sec:basic:exH4plot}--\ref{sec:basic:exH4vecz2},
\ref{sec:basic:exHclass}--\ref{sec:basic:ex:piecewisefunc:mod}),
inverse functions (\ref{sec:class:ex28}, \ref{sec:ode:ex9}--\ref{sec:ode:ex12}),
falling objects
(\ref{sec:ode:ex4}, \ref{sec:ode2:ex22}, \ref{sec:ode2:ex24}, \ref{sec:ode2:ex21}, \ref{sec:ode2:ex27v4}),
oscillatory population growth
(\ref{sec:diffeq:ex16}, \ref{sec:diffeq:ex17}, \ref{sec:diffeq:ex18}, \ref{sec:diffeq:ex19}, \ref{sec:diffeq:ex20}),
epidemic disease modeling (\ref{sec:ode:ex14}--\ref{sec:ode:ex20}),
analysis of web data
(\ref{sec:files:ex8}, \ref{sec:files:ex27}--\ref{sec:files:ex30}),
graphics and animation
(\ref{sec:oo:ex12}--\ref{sec:oo:ex13b}),
optimization and finance
(\ref{sec:diffeq:ex21}, \ref{sec:random:ex26}, \ref{sec:random:ex16}),
statistics and probability
(\ref{sec:input:ex15}--\ref{sec:input:ex16}, \ref{sec:random:ex19}--\ref{sec:random:ex40}),
hazard games
(\ref{sec:random:ex11}--\ref{sec:random:ex45}),
random walk and statistical physics
(\ref{sec:random:ex1}--\ref{sec:random:ex39}),
%, \ref{sec:random:ex3}, \ref{sec:random:ex33}, \ref{sec:random:ex34}, \ref{sec:random:ex36}, \ref{sec:random:ex37}, \ref{sec:random:ex38}, ,
noisy data analysis
(\ref{sec:random:ex22}--\ref{sec:oo:ex23}),
numerical methods
(\ref{sec:class:ex27}, \ref{sec:class:ex27b}, \ref{sec:class:ex27c}, \ref{sec:diffeq:ex14}, \ref{sec:class:ex13c}, \ref{sec:oo:ex16}--\ref{sec:oo:ex41}, \ref{sec:ode2:ex25b2}--\ref{sec:ode2:ex29}),
building a calculus calculator
(\ref{sec:plot:ex28}, \ref{sec:plot:ex29}, \ref{sec:plot:ex30}, \ref{sec:plot:ex30b}),
and creating a toolkit for
simulating vibrating engineering
systems (\ref{sec:ode2:ex34}--\ref{sec:ode2:ex39}).

Chapters~\ref{ch:formula1}--\ref{ch:oo} and Appendix~\ref{ch:ode2}
have, from 2007,
formed the core of an introductory first-semester course on scientific
programming, INF1100, at the University of Oslo (see below).


%At numerous places throughout this book we also refer to our
%\emph\ref{pyinfo page}:
%bccq
%http://www.simula.no/intro-programming/pyinfo.html
%eccq
%This is a Web page with lots of useful
%links for Python programmers.
%The address of the page and
%some explanation of what it contains are given in
%Appendix~\ref\ref{appendix:pyinfo}.

\para{Changes to the First Edition.}
Besides numerous corrections of misprints, the second edition features
a major reorganization of several chapters.
Chapter 2 in the first edition, \emph{Basic Constructions}, was a
comprehensive chapter, both with respect to length and topics.
This chapter has therefore
been split in two for the second edition: a new Chapter 2
\emph{Loops and Lists} and a new Chapter 3 \emph{Functions and Branching}.
A new Chapter
\ref{sec:basic:sumloop} explicitly explains how to implement
a summation expression by a loop,
and later examples present alternative implementations.

All text and program files that used the \emp{getopt} module to parse
command-line options in the first edition now make use of the simpler
and more flexible \emp{argparse} module (new in Python v2.7/3.1).

The material on curve plotting in Chapter~\ref{ch:plot} has been
thoroughly revised. Now we give an introduction to plotting with
Matplotlib as well as SciTools/Easyviz. Both tools are very similar from a
syntax point of view.  Much of the more detailed information on Easyviz
plotting in the first edition has been removed, and the reader is
directed to the online manuals for more details.

While the first edition almost exclusively
used ``star import'' for convenience (e.g., \emp{from numpy import *}
and \emp{from scitools.std import *}), the second edition tries to
adhere to the standard \emp{import numpy as np}. However, in
mathematical formulas that are to work with scalar \emph{and} array
variables, we do not want an explicit prefix. Avoiding the namespace prefixes
is important for making formulas as close to the mathematical notation
as possible as well as for making the transition from or to Matlab
smooth. The two import styles have different merits and applications.
The choice of style in various examples is carefully thought through
in the second edition.

Chapter 5 in the first edition, \emph{Sequences and Difference Equations},
has now become Appendix~\ref{ch:diffeq}
since the material is primarily about mathematical modeling, and no
new basic programming concepts are introduced.
%This appendix is well
%suited for training the fundamental concepts in
%Chapters~\ref{ch:formula1}--\ref{ch:plot}, using simple mathematical
%models.

Chapter 6 in the first edition, \emph{Files, Strings, and Dictionaries},
has been substantially revised.
Now, Chapter~\ref{sec:files:webtxt}, on downloading and interpreting
data from web pages, have completely new examples. Many of the exercises in
this chapter are also reworked to fit with the new examples.

The material on differential equations in chapters on classes (Ch.~7
and 9 in the first edition) has been extracted, reworked,
slightly expanded, and placed in Appendix~\ref{ch:ode2}.
This restructuring allows a
more flexible treatment of differential equations, and parts of this
important topic can be addressed right after Chapter~\ref{ch:funcif}, if
desired. Also, the changes make readers of
Chapters~\ref{ch:class} and \ref{ch:oo} less disturbed with more
difficult mathematical subjects.

To distinguish between Python's \emp{random} module and the one
in \emp{numpy}, we have in Chapter~\ref{ch:random} changed practice
compared with the first edition. Now \emp{random} always refers
to Python's \emp{random} module, while the \emp{random} module in
\emp{numpy} is normally invoked as \emp{np.random} (or occasionally
as \emp{numpy.random}). The associated software has
been revised similarly.


\para{Changes to the Second Edition.}
In the the third edition,
a lot of typos have been fixed;
many examples have been improved;
some material has been reorganized and extended
(Chapter~\ref{sec:input:argparse} on command-line parsing,
Chapter~\ref{sec:plot:if:vectorize} on vectorization,
Append~\ref{sec:ode2:ODE:app:2} on building simulation software,
Exercises~\ref{sec:ode2:ex35}--ref{sec:ode2:ex40});
some material is new
(Chapter~\ref{sec:files:dict:default:order} on dictionaries with
default values and ordering,
Appendix~\ref{sec:diffeq:integral} on integrals as difference equations,
Appendix~\ref{appendix:MC_Cython} on using Cython and combining
Python with fast C code);
some exercises have been removed and many new ones added;
and many exercises are reformulated after feedback from
use in teaching.
The associated \emp{scitools} package is also extensively upgraded.

Three new projects are added: one on
piecewise constant functions (\ref{sec:basic:exH1}--\ref{sec:basic:exH5},
\ref{sec:plot:ex32}, \ref{sec:basic:exH4plot}--\ref{sec:basic:exH4vecz2},
\ref{sec:basic:exHclass}--\ref{sec:basic:ex:piecewisefunc:mod}),
one on
inverse functions (\ref{sec:class:ex28}, \ref{sec:ode:ex9}--\ref{sec:ode:ex12}),
and one on epidemic modeling (\ref{sec:ode:ex14}--\ref{sec:ode:ex20}).

many new exercises, especially on ODEs,



\para{Acknowledgments.}
First, I want to express my thanks
to Aslak Tveito for his enthusiastic role in the
initiation of this book project and for writing
Appendices~\ref{ch:dcalculus} and \ref{ch:ode1} about numerical
methods. Without Aslak there would be no book.  Another key
contributor is Ilmar Wilbers.  His extensive efforts with assisting
the book project and help establishing the associated course (INF1100) at the
University of Oslo are greatly appreciated. Without Ilmar and his
solutions to numerous technical problems the book would never have
been completed. Johannes H.~Ring also deserves a special
acknowledgment for the development of the Easyviz graphics tool, which
is much used throughout this book, and for his careful maintenance and
support of software associated with this book.

Several people have helped to make substantial improvements of the
text, the exercises, and the associated software infrastructure. The
author is thankful to Ingrid Eide, St{\aa}le Zerener Haugn{\ae}ss,
Kristian Hiorth,
Arve Knudsen, Tobias Vidarss{\o}nn Langhoff, Martin Vonheim Larsen,
Kine Veronica Lund,
Solveig Masvie, H{\aa}kon M{\o}ller, Rebekka M{\o}rken,
Mathias Nedreb{\o},
Marit Sandstad, Hele Norheim Semmerud, Lars Storjord,
Fredrik Heffer Valdmanis, and Torkil Vederhus for their
contributions. Hakon Adler is greatly acknowledged for his careful
reading of various versions of the manuscript.  The professors Fred
Espen Bent, {\O}rnulf Borgan, Geir Dahl, Knut M{\o}rken, and Geir
Pedersen have contributed with many exciting exercises from various
application fields. Great thanks also go to Jan Olav Langseth for
creating the cover image.

This book and the associated course are parts of a comprehensive
reform at the University of Oslo, called \emph{Computers in Science
Education}. The goal of the reform is to integrate computer
programming and simulation in all bachelor courses in natural science
where mathematical models are used.  The present book lays the
foundation for the modern computerized problem solving technique to be
applied in later courses.  It has been extremely inspiring to work
with the driving forces behind this reform, in particular the
professors Morten Hjorth--Jensen, Anders Malthe--S{\o}renssen, Knut
M{\o}rken, and Arnt Inge Vistnes.

The excellent assistance from the Springer and le-tex teams,
consisting of Martin Peters, Thanh-Ha Le Thi, Ruth Allewelt, Peggy
Glauch-Ruge, Nadja Kroke, Thomas Schmidt, and Patrick Waltemate,
is highly appreciated, and ensured a smooth and rapid production of both
the first and the second edition of this book.

\vspace{1cm}

\noindent
{\it Oslo, February 2011}\hfill {\it Hans Petter Langtangen}


